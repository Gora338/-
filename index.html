<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Таврели в 3D</title>
    <!-- Добавления для PWA (из Шага 1) -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#87CEEB">  <!-- Цвет темы (небесно-голубой, как фон доски) -->
    <meta name="apple-mobile-web-app-capable" content="yes">  <!-- Для iOS: запуск как приложение -->
    <meta name="apple-mobile-web-app-status-bar-style" content="default">  <!-- Стиль статус-бара для iOS -->
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; z-index: 10; }
        #gameOver { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: white; background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; text-align: center; 
            display: none; z-index: 20; border: 2px solid gold; box-shadow: 0 0 20px rgba(255,215,0,0.5);
            font-size: 1.2em; min-width: 250px;
        }
        #gameOver h2 { color: gold; margin-bottom: 20px; }
        #gameOver button { padding: 10px 20px; background: gold; color: black; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; }
        #gameOver button:hover { background: #ffd700; }
        #endMessage { margin: 10px 0; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="ui">
        <div>Текущий игрок: <span id="currentPlayer">Белые</span></div>
        <div id="selected">Выберите фигуру</div>
        <div id="status"></div>
    </div>
    <div id="gameOver">
        <h2 id="gameOverText"></h2>
        <p id="endMessage"></p>
        <button onclick="location.reload()">Начать заново</button>
    </div>
    <script>
        // Регистрация Service Worker (из Шага 2, для оффлайн-доступа)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then((reg) => console.log('SW registered!', reg))
                .catch((err) => console.log('SW registration failed: ', err));
        }

        // Сцена, камера, рендерер
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Контролы - всегда включены для вращения
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 20;
        controls.enableRotate = true; // Всегда разрешено вращение

        let isInteracting = false;
        controls.addEventListener('start', () => { isInteracting = true; });
        controls.addEventListener('end', () => { setTimeout(() => { isInteracting = false; }, 100); });

        // Освещение
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 10, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Доска
        const board = [];
        const squareSize = 1;
        for (let x = 0; x < 8; x++) {
            board[x] = [];
            for (let z = 0; z < 8; z++) {
                const geometry = new THREE.BoxGeometry(squareSize, 0.1, squareSize);
                const material = new THREE.MeshLambertMaterial({ color: (x + z) % 2 === 0 ? 0xdeb887 : 0x8b4513 });
                const square = new THREE.Mesh(geometry, material);
                square.position.set(x - 3.5, 0, z - 3.5);
                scene.add(square);
                board[x][z] = { mesh: square, pieces: [] };
            }
        }

        // Подсветка
        let highlightMeshes = [];

        function clearHighlights() {
            highlightMeshes.forEach(mesh => scene.remove(mesh));
            highlightMeshes = [];
        }

        function showHighlights(moves) {
            clearHighlights();
            moves.forEach(([tx, tz]) => {
                const geometry = new THREE.CircleGeometry(0.42, 32);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
                const highlight = new THREE.Mesh(geometry, material);
                highlight.rotation.x = -Math.PI / 2;
                highlight.position.set(tx - 3.5, 0.06, tz - 3.5);
                scene.add(highlight);
                highlightMeshes.push(highlight);
            });
        }

        // Анимация превращения
        let promotingPieces = [];

        // Создание фигур
        function createPiece(color, type = 'ratnik', potentialType = null, isTransformed = false, originalPotentialType = null) {
            let materialColor = color === 'white' ? 0xffffff : 0x333333;
            let geometryType;
            let scale = 1;
            if (type === 'ratnik') {
                if (potentialType) {
                    // Мини-версия potentialType для визуального отличия
                    geometryType = getGeometryForType(potentialType);
                    scale = 0.5;
                    // Немного другой оттенок для понимания, что это пешка
                    materialColor = color === 'white' ? 0xeeeeee : 0x555555;
                } else {
                    geometryType = new THREE.SphereGeometry(0.4);
                }
            } else {
                geometryType = getGeometryForType(type);
            }
            const material = new THREE.MeshLambertMaterial({ color: materialColor });
            const piece = new THREE.Mesh(geometryType, material);
            piece.scale.setScalar(scale);
            piece.userData = { 
                color, 
                type, 
                potentialType,
                originalPotentialType,
                isTransformedRatnik: isTransformed,
                selected: false, 
                hasMoved: type === 'ratnik' ? false : true 
            };
            return piece;
        }

        function getGeometryForType(type) {
            switch (type) {
                case 'volhv': return new THREE.CylinderGeometry(0.3, 0.3, 0.6);
                case 'super': return new THREE.ConeGeometry(0.35, 0.7, 12); // Специальная геометрия для super (конь+ферзь)
                case 'vsadnik': return new THREE.TorusGeometry(0.3, 0.1, 8, 6);
                case 'knyaz': return new THREE.ConeGeometry(0.4, 0.8, 8);
                case 'rato_borec': return new THREE.BoxGeometry(0.5, 0.2, 0.5);
                case 'luchnik': return new THREE.OctahedronGeometry(0.4);
                default: return new THREE.SphereGeometry(0.4);
            }
        }

        // Функция для обновления геометрии фигуры (для превращения) с анимацией
        function updatePieceGeometry(piece, newType, newPotential = null, newIsTransformed = false, originalPotential = null, animate = false) {
            const oldPos = piece.position.clone();
            const oldScale = piece.scale.clone();
            scene.remove(piece);
            const newPiece = createPiece(piece.userData.color, newType, newPotential, newIsTransformed, originalPotential);
            newPiece.position.copy(oldPos);
            newPiece.userData.hasMoved = piece.userData.hasMoved;
            // Заменяем в стеке
            const x = Math.round(oldPos.x + 3.5);
            const z = Math.round(oldPos.z + 3.5);
            const stack = board[x][z].pieces;
            const idx = stack.indexOf(piece);
            if (idx !== -1) {
                stack[idx] = newPiece;
            }
            if (animate) {
                // Анимация: начать с scale 0 и вращением
                newPiece.scale.setScalar(0);
                newPiece.rotation.y = 0;
                promotingPieces.push({
                    piece: newPiece,
                    startTime: Date.now(),
                    targetScale: oldScale.clone().multiplyScalar(2) // Чтобы выросла до полного размера
                });
            } else {
                newPiece.scale.copy(oldScale);
            }
            scene.add(newPiece);
            return newPiece;
        }

        // Начальная расстановка
        const pieceTypesWhite = ['rato_borec', 'vsadnik', 'luchnik', 'knyaz', 'volhv', 'luchnik', 'vsadnik', 'rato_borec'];
        const pieceTypesBlack = ['rato_borec', 'vsadnik', 'luchnik', 'knyaz', 'volhv', 'luchnik', 'vsadnik', 'rato_borec'];
        // Ратники
        for (let x = 0; x < 8; x++) {
            const potentialW = pieceTypesWhite[x];
            const pieceW = createPiece('white', 'ratnik', potentialW);
            pieceW.position.set(x - 3.5, 0.2, 6 - 3.5);
            board[x][6].pieces.push(pieceW);
            scene.add(pieceW);

            const potentialB = pieceTypesBlack[x];
            const pieceB = createPiece('black', 'ratnik', potentialB);
            pieceB.position.set(x - 3.5, 0.2, 1 - 3.5);
            board[x][1].pieces.push(pieceB);
            scene.add(pieceB);
        }
        // Задний ряд
        for (let x = 0; x < 8; x++) {
            const type = pieceTypesWhite[x];
            const piece = createPiece('white', type);
            piece.position.set(x - 3.5, 0.2, 7 - 3.5);
            board[x][7].pieces.push(piece);
            scene.add(piece);
            const typeB = pieceTypesBlack[x];
            const pieceB = createPiece('black', typeB);
            pieceB.position.set(x - 3.5, 0.2, 0 - 3.5);
            board[x][0].pieces.push(pieceB);
            scene.add(pieceB);
        }

        // Клон доски (обновлён для potentialType, isTransformedRatnik и originalPotentialType)
        function cloneBoard(origBoard) {
            const newBoard = [];
            for (let x = 0; x < 8; x++) {
                newBoard[x] = [];
                for (let z = 0; z < 8; z++) {
                    newBoard[x][z] = { pieces: origBoard[x][z].pieces.map(p => {
                        const clone = createPiece(p.userData.color, p.userData.type, p.userData.potentialType, p.userData.isTransformedRatnik, p.userData.originalPotentialType);
                        clone.userData.hasMoved = p.userData.hasMoved;
                        clone.position.copy(p.position);
                        clone.scale.copy(p.scale);
                        return clone;
                    }) };
                }
            }
            return newBoard;
        }

        // Функции ходов (легальные, без волхва)
        function getMoves(piece, x, z, board, player) {
            const moves = getRawMoves(piece, x, z, board, player);
            // Фильтр: исключить цели с волхвом наверху
            const filteredMoves = moves.filter(([mx, mz]) => {
                const targetStack = board[mx][mz].pieces;
                if (targetStack.length > 0 && targetStack[targetStack.length - 1].userData.type === 'volhv') {
                    return false;
                }
                return true;
            });
            return filteredMoves;
        }

        // Raw moves для атак (включая на волхва)
        function getRawMoves(piece, x, z, board, player) {
            const moves = [];
            const dir = player === 'white' ? -1 : 1;
            const opponent = player === 'white' ? 'black' : 'white';
            const type = piece.userData.type;

            function addLineMoves(dx, dz) {
                for (let i = 1; i < 8; i++) {
                    const nx = x + i * dx;
                    const nz = z + i * dz;
                    if (nx < 0 || nx >= 8 || nz < 0 || nz >= 8) break;
                    moves.push([nx, nz]);
                    if (board[nx][nz].pieces.length > 0) break;
                }
            }

            switch (type) {
                case 'volhv':
                    const kingDirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                    kingDirs.forEach(([dx, dz]) => {
                        const nx = x + dx, nz = z + dz;
                        if (nx >= 0 && nx < 8 && nz >= 0 && nz < 8) moves.push([nx, nz]);
                    });
                    break;
                case 'super':
                    // Конь + ферзь: knight moves + queen lines
                    const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                    knightMoves.forEach(([dx, dz]) => {
                        const nx = x + dx, nz = z + dz;
                        if (nx >= 0 && nx < 8 && nz >= 0 && nz < 8) moves.push([nx, nz]);
                    });
                    addLineMoves(1, 0); addLineMoves(-1, 0); addLineMoves(0, 1); addLineMoves(0, -1);
                    addLineMoves(1, 1); addLineMoves(-1, -1); addLineMoves(1, -1); addLineMoves(-1, 1);
                    break;
                case 'vsadnik':
                    const knightMoves2 = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                    knightMoves2.forEach(([dx, dz]) => {
                        const nx = x + dx, nz = z + dz;
                        if (nx >= 0 && nx < 8 && nz >= 0 && nz < 8) moves.push([nx, nz]);
                    });
                    break;
                case 'knyaz':
                    addLineMoves(1, 0); addLineMoves(-1, 0); addLineMoves(0, 1); addLineMoves(0, -1);
                    addLineMoves(1, 1); addLineMoves(-1, -1); addLineMoves(1, -1); addLineMoves(-1, 1);
                    break;
                case 'rato_borec':
                    addLineMoves(1, 0); addLineMoves(-1, 0); addLineMoves(0, 1); addLineMoves(0, -1);
                    break;
                case 'luchnik':
                    addLineMoves(1, 1); addLineMoves(-1, -1); addLineMoves(1, -1); addLineMoves(-1, 1);
                    break;
                case 'ratnik':
                    const fwd1 = [x, z + dir];
                    if (fwd1[1] >= 0 && fwd1[1] < 8 && board[fwd1[0]][fwd1[1]].pieces.length === 0) moves.push(fwd1);
                    if (!piece.userData.hasMoved) {
                        const fwd2 = [x, z + 2 * dir];
                        const midZ = z + dir;
                        if (fwd2[1] >= 0 && fwd2[1] < 8 && board[x][midZ].pieces.length === 0 && board[x][fwd2[1]].pieces.length === 0) {
                            moves.push(fwd2);
                        }
                    }
                    [[1, dir], [-1, dir]].forEach(([dx, dz]) => {
                        const nx = x + dx, nz = z + dz;
                        if (nx >= 0 && nx < 8 && nz >= 0 && nz < 8) {
                            const targetStack = board[nx][nz].pieces;
                            if (targetStack.length > 0 && targetStack[targetStack.length - 1].userData.color === opponent) moves.push([nx, nz]);
                        }
                    });
                    break;
            }
            return moves;
        }

        // Атака (использует raw moves, включая на волхва)
        function isUnderAttack(x, z, attackerColor, simBoard) {
            for (let ax = 0; ax < 8; ax++) {
                for (let az = 0; az < 8; az++) {
                    const stack = simBoard[ax][az].pieces;
                    if (stack.length === 0) continue;
                    const topPiece = stack[stack.length - 1];
                    if (topPiece.userData.color === attackerColor) {
                        const attacks = getRawMoves(topPiece, ax, az, simBoard, attackerColor);
                        if (attacks.some(([mx, mz]) => mx === x && mz === z)) return true;
                    }
                }
            }
            return false;
        }

        // Волхв (поиск в стеке)
        function findVolhv(player, simBoard = board) {
            for (let x = 0; x < 8; x++) {
                for (let z = 0; z < 8; z++) {
                    const stack = simBoard[x][z].pieces;
                    for (let p of stack) {
                        if (p.userData.type === 'volhv' && p.userData.color === player) {
                            return { x, z, stack };
                        }
                    }
                }
            }
            return null;
        }

        // Шах
        function isInCheck(player, simBoard) {
            const volhv = findVolhv(player, simBoard);
            if (!volhv) return false;
            const opponent = player === 'white' ? 'black' : 'white';
            return isUnderAttack(volhv.x, volhv.z, opponent, simBoard);
        }

        // Есть ли легальные ходы (использует getMoves)
        function hasLegalMoves(player, origBoard) {
            for (let x = 0; x < 8; x++) {
                for (let z = 0; z < 8; z++) {
                    const stack = origBoard[x][z].pieces;
                    if (stack.length === 0) continue;
                    const topPiece = stack[stack.length - 1];
                    if (topPiece.userData.color !== player) continue;
                    for (let subIdx = 0; subIdx < stack.length; subIdx++) {
                        const moves = getMoves(topPiece, x, z, origBoard, player);
                        for (let [tx, tz] of moves) {
                            const simBoard = simulateMove(origBoard, x, z, tx, tz, subIdx, player);
                            if (!isInCheck(player, simBoard)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Симуляция (без изменений, но теперь с potential и transformed)
        function simulateMove(origBoard, fromX, fromZ, toX, toZ, subIndex, player) {
            const simBoard = cloneBoard(origBoard);
            const stack = simBoard[fromX][fromZ].pieces;
            const movingPieces = stack.splice(subIndex);
            const newStack = simBoard[toX][toZ].pieces;
            const baseHeight = newStack.length * 0.6 + 0.2;
            movingPieces.forEach((p, i) => {
                const height = baseHeight + i * 0.6;
                p.position.set(toX - 3.5, height, toZ - 3.5);
            });
            newStack.push(...movingPieces);
            return simBoard;
        }

        // Функция для обработки превращения и реверса после хода
        function handleTransformationsAfterMove(targetX, targetZ, player) {
            const targetStack = board[targetX][targetZ].pieces;
            if (targetStack.length === 0) return;

            let promotionMessage = null;

            // Проверка превращения: только если пешка на вершине башни (top) и на lastRow, независимо от захвата
            const topPiece = targetStack[targetStack.length - 1];
            const lastRow = player === 'white' ? 0 : 7;
            if (topPiece.userData.type === 'ratnik' && targetZ === lastRow && topPiece.userData.potentialType) {
                let transformType = topPiece.userData.potentialType;
                // Специальный случай: если potential 'volhv', преврати в 'super'
                if (transformType === 'volhv') {
                    transformType = 'super';
                }
                const originalPotential = topPiece.userData.potentialType;
                // Превращение в transformType с анимацией
                updatePieceGeometry(topPiece, transformType, null, true, originalPotential, true);
                promotionMessage = `Превращение в ${transformType === 'super' ? 'супер-волхва' : transformType}!`;
            }

            // Реверс: для всех в стеке кроме вершины, если isTransformedRatnik, преврати обратно в ratnik с originalPotentialType
            for (let i = 0; i < targetStack.length - 1; i++) {
                const p = targetStack[i];
                if (p.userData.isTransformedRatnik && p.userData.originalPotentialType !== null) {
                    updatePieceGeometry(p, 'ratnik', p.userData.originalPotentialType, false);
                }
            }

            if (promotionMessage) {
                document.getElementById('status').textContent = promotionMessage;
            }
        }

        // Камера
        camera.position.set(0, 10, 5);
        controls.target.set(0, 0, 0);

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedStack = null;
        let currentPlayer = 'white';

        function updateUI() {
            document.getElementById('currentPlayer').textContent = currentPlayer === 'white' ? 'Белые' : 'Чёрные';
            document.getElementById('selected').textContent = selectedStack ? `Выбрана подбашня (${selectedStack.stack.length - selectedStack.index} фигур)` : 'Выберите фигуру';
            
            const playerToMove = currentPlayer;
            const opponent = playerToMove === 'white' ? 'black' : 'white';
            const inCheck = isInCheck(playerToMove, board);
            const hasLegal = hasLegalMoves(playerToMove, board);
            let status = document.getElementById('status').textContent;
            let showGameOver = false;
            let gameOverText = '';
            let endMessage = '';

            if (!hasLegal) {
                showGameOver = true;
                if (inCheck) {
                    gameOverText = `Мат! ${opponent === 'white' ? 'Белые' : 'Чёрные'} победили!`;
                    endMessage = `Победа за ${opponent === 'white' ? 'белыми' : 'чёрными'}!`;
                } else {
                    gameOverText = 'Ничья!';
                    endMessage = 'Игра окончена вничью по отсутствию ходов.';
                }
            } else if (inCheck) {
                status = 'Шах!';
            }

            document.getElementById('status').textContent = status;
            if (showGameOver) {
                document.getElementById('gameOverText').textContent = gameOverText;
                document.getElementById('endMessage').textContent = endMessage;
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        function highlightSubstack(substack, isSelected) {
            substack.forEach(p => {
                p.material.color.set(isSelected ? 0x00ff00 : (p.userData.color === 'white' ? 0xffffff : 0x333333));
            });
        }

        function onClick(event) {
            // Убрана проверка isInteracting - теперь клики работают сразу, даже после вращения камеры
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            if (!clientX) return;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                let ix, iz, stack, index;

                if (obj.userData && !selectedStack) {
                    // Выбор по фигуре (с поддержкой плен)
                    ix = Math.round(obj.position.x + 3.5);
                    iz = Math.round(obj.position.z + 3.5);
                    stack = board[ix][iz].pieces;
                    index = stack.indexOf(obj);
                    if (index !== -1) {
                        const topPiece = stack[stack.length - 1];
                        const topColor = topPiece.userData.color;
                        // Можно выбрать, если кликнутая фигура твоя ИЛИ (плен: кликнутая чужая, но верхняя твоя)
                        if (obj.userData.color === currentPlayer || (obj.userData.color !== currentPlayer && topColor === currentPlayer)) {
                            selectedStack = { stack, index };
                            const substack = stack.slice(index);
                            highlightSubstack(substack, true);
                            const rawMoves = getMoves(topPiece, ix, iz, board, currentPlayer);
                            // Фильтруем на легальные ходы (без оставления в шахе)
                            const legalMoves = [];
                            rawMoves.forEach(([tx, tz]) => {
                                const simBoard = simulateMove(board, ix, iz, tx, tz, index, currentPlayer);
                                if (!isInCheck(currentPlayer, simBoard)) {
                                    legalMoves.push([tx, tz]);
                                }
                            });
                            showHighlights(legalMoves);
                            updateUI();
                            return;
                        }
                    }
                } else if (!selectedStack) {
                    // Проверка на клик по клетке доски для выбора верхней фигуры
                    if (obj.position.y === 0 && obj.geometry.type === 'BoxGeometry') {
                        ix = Math.round(obj.position.x + 3.5);
                        iz = Math.round(obj.position.z + 3.5);
                        if (ix >= 0 && ix < 8 && iz >= 0 && iz < 8) {
                            stack = board[ix][iz].pieces;
                            if (stack.length > 0) {
                                const topPiece = stack[stack.length - 1];
                                if (topPiece.userData.color === currentPlayer) {
                                    index = stack.length - 1;
                                    selectedStack = { stack, index };
                                    const substack = stack.slice(index);
                                    highlightSubstack(substack, true);
                                    const rawMoves = getMoves(topPiece, ix, iz, board, currentPlayer);
                                    const legalMoves = [];
                                    rawMoves.forEach(([tx, tz]) => {
                                        const simBoard = simulateMove(board, ix, iz, tx, tz, index, currentPlayer);
                                        if (!isInCheck(currentPlayer, simBoard)) {
                                            legalMoves.push([tx, tz]);
                                        }
                                    });
                                    showHighlights(legalMoves);
                                    updateUI();
                                    return;
                                }
                            }
                        }
                    }
                } else if (selectedStack) {
                    // Попытка хода
                    const targetX = Math.round(obj.position.x + 3.5);
                    const targetZ = Math.round(obj.position.z + 3.5);
                    if (targetX >= 0 && targetX < 8 && targetZ >= 0 && targetZ < 8) {
                        const selX = Math.round(selectedStack.stack[0].position.x + 3.5);
                        const selZ = Math.round(selectedStack.stack[0].position.z + 3.5);
                        const topPiece = selectedStack.stack[selectedStack.stack.length - 1];
                        let rawMoves = getMoves(topPiece, selX, selZ, board, currentPlayer);
                        const isRawValid = rawMoves.some(([mx, mz]) => mx === targetX && mz === targetZ);
                        if (isRawValid) {
                            const simBoard = simulateMove(board, selX, selZ, targetX, targetZ, selectedStack.index, currentPlayer);
                            if (!isInCheck(currentPlayer, simBoard)) {
                                const targetStackBefore = board[targetX][targetZ].pieces;
                                const isVolhvTop = targetStackBefore.length > 0 && targetStackBefore[targetStackBefore.length - 1].userData.type === 'volhv';
                                if (!isVolhvTop) {
                                    const movingPieces = selectedStack.stack.splice(selectedStack.index);
                                    movingPieces.forEach(p => p.userData.hasMoved = true);
                                    const newStack = board[targetX][targetZ].pieces;
                                    const baseHeight = newStack.length * 0.6 + 0.2;
                                    movingPieces.forEach((p, i) => {
                                        const height = baseHeight + i * 0.6;
                                        p.position.set(targetX - 3.5, height, targetZ - 3.5);
                                    });
                                    newStack.push(...movingPieces);

                                    // Обработка превращений и реверса
                                    handleTransformationsAfterMove(targetX, targetZ, currentPlayer);

                                    // Фикс превращения: проверка всех стеков на lastRow после хода
                                    const lastRow = currentPlayer === 'white' ? 0 : 7;
                                    for (let x = 0; x < 8; x++) {
                                        for (let z = 0; z < 8; z++) {
                                            if (z === lastRow) {
                                                const stack = board[x][z].pieces;
                                                if (stack.length > 0) {
                                                    const top = stack[stack.length - 1];
                                                    if (top.userData.type === 'ratnik' && top.userData.potentialType) {
                                                        let transformType = top.userData.potentialType;
                                                        if (transformType === 'volhv') transformType = 'super';
                                                        const originalPotential = top.userData.potentialType;
                                                        updatePieceGeometry(top, transformType, null, true, originalPotential, true);
                                                        document.getElementById('status').textContent = `Превращение в ${transformType === 'super' ? 'супер-волхва' : transformType}!`;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // Получаем обновлённые moved pieces из стека для подсветки
                                    const movedInNewStack = board[targetX][targetZ].pieces.slice(-movingPieces.length);

                                    clearHighlights();
                                    highlightSubstack(movedInNewStack, false);
                                    selectedStack = null;
                                    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                                    updateUI();
                                    return;
                                } else {
                                    document.getElementById('status').textContent = 'Нельзя ставить на волхва!';
                                }
                            } else {
                                document.getElementById('status').textContent = 'Ход оставляет шах!';
                            }
                        } else {
                            document.getElementById('status').textContent = 'Недопустимый ход!';
                        }
                        clearHighlights();
                        const substack = selectedStack ? selectedStack.stack.slice(selectedStack.index) : [];
                        highlightSubstack(substack, false);
                        selectedStack = null;
                        updateUI();
                        return;
                    }
                }
            } else {
                // Клик мимо - деселект
                clearHighlights();
                if (selectedStack) {
                    const substack = selectedStack.stack.slice(selectedStack.index);
                    highlightSubstack(substack, false);
                    selectedStack = null;
                    updateUI();
                }
            }
        }

        // Используем 'click' для выбора (fires only on short clicks, drag handled by controls)
        window.addEventListener('click', onClick);

        // Touch support
        window.addEventListener('touchend', (e) => {
            // Simulate click for touch
            onClick(e.changedTouches[0]);
        }, { passive: false });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Анимация превращения
            const now = Date.now();
            promotingPieces = promotingPieces.filter(anim => {
                const elapsed = now - anim.startTime;
                if (elapsed > 800) { // Длительность анимации 800ms
                    anim.piece.scale.copy(anim.targetScale);
                    anim.piece.rotation.y = 0; // Сброс вращения
                    return false;
                }
                const progress = Math.sin(elapsed / 800 * Math.PI); // Плавный рост с sin
                anim.piece.scale.copy(anim.targetScale.clone().multiplyScalar(progress));
                anim.piece.rotation.y += 0.03; // Вращение во время анимации
                return true;
            });

            renderer.render(scene, camera);
        }
        updateUI();
        animate();
    </script>
</body>
</html>