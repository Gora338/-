<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–¢–∞–≤—Ä–µ–ª–∏</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Georgia', serif; /* –≠–ª–µ–≥–∞–Ω—Ç–Ω—ã–π —à—Ä–∏—Ñ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω */
            background: linear-gradient(135deg, #0f0f23 0%, #000000 100%); /* –ù–æ–≤—ã–π —Ç—ë–º–Ω—ã–π –∫–æ—Å–º–∏—á–µ—Å–∫–∏–π/—Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–π —Ñ–æ–Ω: —Ç—ë–º–Ω–æ-—Å–∏–Ω–∏–π –∫ —á—ë—Ä–Ω–æ–º—É */
            color: #e0e0ff; /* –°–≤–µ—Ç–ª–æ-—Å–∏–Ω–∏–π —Ç–µ–∫—Å—Ç –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞ */
        }
        canvas { display: block; }
        
        /* –ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω (Menu) ‚Äî –Ω–æ–≤—ã–π –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –¥–∏–∑–∞–π–Ω */
        #mainMenu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; background: rgba(0,0,0,0.8); /* –ë–æ–ª–µ–µ —Ç—ë–º–Ω—ã–π –æ–≤–µ—Ä–ª–µ–π */
        }
        #mainMenu h1 {
            font-size: 2.67em;
            font-style: italic;
            text-shadow: 2px 2px 8px rgba(0,0,0,1), 0 0 15px rgba(224,224,255,0.6); /* –°–∏–Ω–∏–π glow */
            margin-bottom: 33px;
            color: #e0e0ff; /* –°–≤–µ—Ç–ª–æ-—Å–∏–Ω–∏–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ */
            letter-spacing: 2px;
        }
        .menuButton {
            background: linear-gradient(145deg, #4a4a8a, #2a2a5a); /* –¢—ë–º–Ω–æ-—Å–∏–Ω–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –∫–Ω–æ–ø–æ–∫ */
            border: 2px solid #6a6a9a; /* –°–∏–Ω–∏–π –±–æ—Ä–¥–µ—Ä */
            border-radius: 10px;
            color: #e0e0ff; font-size: 1.33em;
            font-weight: bold; padding: 10px 27px;
            margin: 13px;
            cursor: pointer; transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.2); /* –¢—ë–º–Ω–∞—è —Ç–µ–Ω—å */
            text-shadow: none;
            position: relative;
        }
        .menuButton:hover {
            background: linear-gradient(145deg, #5a5aa0, #3a3a7a); transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,1), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .menuButton:disabled {
            background: #333; border-color: #555; cursor: not-allowed; opacity: 0.5;
        }
        
        /* –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω (—Å–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é) ‚Äî –æ–±–Ω–æ–≤–ª—ë–Ω UI */
        #gameContainer {
            display: none;
        }
        #ui { position: absolute; top: 10px; left: 10px; color: #e0e0ff; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 10; border: 1px solid #4a4a8a; }
        #gameOver { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: #e0e0ff; background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; text-align: center; 
            display: none; z-index: 20; border: 2px solid #6a6a9a; box-shadow: 0 0 20px rgba(74,74,138,0.5); /* –°–∏–Ω–∏–π glow */
            font-size: 1.2em; min-width: 250px;
        }
        #gameOver h2 { color: #e0e0ff; margin-bottom: 20px; }
        #gameOver button { padding: 10px 20px; background: #4a4a8a; color: #e0e0ff; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        #gameOver button:hover { background: #5a5aa0; }
        #endMessage { margin: 10px 0; }
        #errorMessage { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: #ff6b6b; background: rgba(0,0,0,0.9); padding: 20px; border-radius: 10px; text-align: center; 
            display: none; z-index: 30; font-size: 1.1em; min-width: 200px; border: 1px solid #ff6b6b;
        }
        
        /* –£–±—Ä–∞–Ω–∞ –¥–æ—Å–∫–∞ –≤ —Ñ–æ–Ω–µ ‚Äî #menuBoard —É–¥–∞–ª—ë–Ω */

        /* –ù–æ–≤–∞—è –Ω–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ ‚Äî –ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∞–Ω–∞: —Ç—ë–º–Ω–∞—è, –±–µ–∑ –Ω–∞–ª–æ–∂–µ–Ω–∏–π */
        #bottomNav {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 60px;
            background: linear-gradient(145deg, #1a1a3a, #0a0a1a); /* –¢—ë–º–Ω–æ-—Å–∏–Ω–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç, opaque */
            border-top: 2px solid #4a4a8a; /* –°–∏–Ω–∏–π –±–æ—Ä–¥–µ—Ä */
            display: flex; justify-content: space-between; align-items: center; /* space-between –¥–ª—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è */
            z-index: 200; box-shadow: 0 -4px 12px rgba(0,0,0,0.9); /* –£—Å–∏–ª–µ–Ω–Ω–∞—è —Ç–µ–Ω—å –≤–≤–µ—Ä—Ö */
            font-family: 'Georgia', serif; font-size: 1em; color: #e0e0ff; font-weight: bold;
            padding: 0 10px; /* –î–æ–±–∞–≤–ª–µ–Ω padding –¥–ª—è –∫—Ä–∞—ë–≤ */
            box-sizing: border-box;
        }
        .navContainer { /* –ù–æ–≤—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–æ–∫: 4 –∫–Ω–æ–ø–∫–∏ –≤ flex */
            display: flex; justify-content: space-around; width: calc(100% - 70px); /* –£–º–µ–Ω—å—à–µ–Ω–æ –º–µ—Å—Ç–æ –¥–ª—è hamburger (—Ç–µ–ø–µ—Ä—å –∫–∞–∫ –∫–Ω–æ–ø–∫–∞ —Å —Ç–µ–∫—Å—Ç–æ–º) */
        }
        .navButton {
            background: none; border: none; padding: 5px 10px; cursor: pointer; transition: all 0.3s ease; /* –£–º–µ–Ω—å—à–µ–Ω padding */
            color: #e0e0ff; text-shadow: none;
            display: flex; flex-direction: column; align-items: center; flex: 1; /* –†–∞–≤–Ω–æ–º–µ—Ä–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –±–µ–∑ –Ω–∞–ª–æ–∂–µ–Ω–∏–π */
            max-width: 70px; /* –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —à–∏—Ä–∏–Ω—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö */
        }
        .navButton .icon { font-size: 1.2em; margin-bottom: 2px; }
        .navButton:hover, .navButton.active {
            color: #a0a0ff; transform: scale(1.05);
        }
        #hamburger {
            background: none; border: none; cursor: pointer; transition: all 0.3s ease;
            color: #e0e0ff; text-shadow: none;
            display: flex; flex-direction: column; align-items: center; /* –ö–∞–∫ –¥—Ä—É–≥–∏–µ –∫–Ω–æ–ø–∫–∏: column —Å –∏–∫–æ–Ω–∫–æ–π –∏ —Ç–µ–∫—Å—Ç–æ–º */
            width: 50px; height: 50px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä */
            margin-left: 10px;
        }
        #hamburger .icon { font-size: 1.5em; margin-bottom: 2px; } /* –ò–∫–æ–Ω–∫–∞ –±–æ–ª—å—à–µ */
        #hamburger span { font-size: 0.8em; } /* –¢–µ–∫—Å—Ç –ø–æ–º–µ–Ω—å—à–µ */
        #hamburger:hover { color: #a0a0ff; transform: scale(1.05); }

        /* –ë–æ–∫–æ–≤–∞—è –ø–∞–Ω–µ–ª—å (sidebar) ‚Äî –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã—Ç–∞, –≤—ã–¥–≤–∏–≥–∞–µ—Ç—Å—è –±–µ–∑ "–∑–∞–ª–µ–∑–∞–Ω–∏—è" */
        #sidebar {
            position: fixed; left: -300px; top: 0; width: 250px; height: 100%; /* left: -300px —á—Ç–æ–±—ã –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã—Ç—å —Å padding:20px + box-shadow:4px + –∑–∞–ø–∞—Å */
            background: linear-gradient(145deg, #2a2a5a, #1a1a3a); /* –¢—ë–º–Ω–æ-—Å–∏–Ω–∏–π */
            transition: left 0.3s ease; /* –¢–æ–ª—å–∫–æ left –¥–ª—è —á–∏—Å—Ç–æ–≥–æ slide */
            z-index: 300;
            padding: 20px; box-shadow: 4px 0 12px rgba(0,0,0,0.9); /* –¢–µ–Ω—å —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ */
            overflow: hidden; /* –ß—Ç–æ–±—ã –Ω–∏—á–µ–≥–æ –Ω–µ —Ç–æ—Ä—á–∞–ª–æ */
        }
        #sidebar.open { 
            left: 0; /* –í—ã–¥–≤–∏–≥–∞–µ—Ç—Å—è –ø–æ–ª–Ω–æ—Å—Ç—å—é */
        }
        /* Overlay ‚Äî —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω, –±–µ–∑ "–¥–≤–æ–π–Ω–æ–≥–æ" —ç—Ñ—Ñ–µ–∫—Ç–∞ */
        #sidebarOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); z-index: 250;
            display: none; transition: opacity 0.3s ease; /* –°–∏–Ω—Ö—Ä–æ–Ω —Å sidebar */
        }
        #sidebarOverlay.open { display: block; opacity: 1; }
        #sidebar ul { list-style: none; padding: 0; margin: 0; }
        #sidebar li { margin: 15px 0; }
        #sidebar a { color: #e0e0ff; text-decoration: none; font-size: 1.1em; display: block; padding: 10px; border-radius: 5px; transition: background 0.3s; }
        #sidebar a:hover { background: rgba(160,160,255,0.2); }
        #closeSidebar { position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: #e0e0ff; }

        /* –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞ */
        #multiplayerModal {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; height: 60%; max-width: 500px; background: linear-gradient(145deg, #2a2a5a, #1a1a3a);
            z-index: 400; border: 2px solid #6a6a9a; border-radius: 15px; padding: 20px;
            overflow-y: auto; box-shadow: 0 0 30px rgba(74,74,138,0.8);
            color: #e0e0ff; font-family: 'Georgia', serif;
        }
        #multiplayerModal h2 { text-align: center; margin-bottom: 20px; }
        .modal-field { margin-bottom: 15px; }
        .modal-field label { display: block; font-weight: bold; margin-bottom: 5px; }
        .modal-field input { background: #4a4a8a; border: 1px solid #6a6a9a; color: #e0e0ff; padding: 8px; border-radius: 5px; width: 100px; }
        .modal-field select { background: #4a4a8a; border: 1px solid #6a6a9a; color: #e0e0ff; padding: 8px; border-radius: 5px; margin-left: 10px; }
        #presetGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px 0; }
        .presetButton { background: linear-gradient(145deg, #4a4a8a, #2a2a5a); border: 1px solid #6a6a9a; color: #e0e0ff; padding: 10px; border-radius: 10px; cursor: pointer; transition: all 0.3s; text-align: center; font-weight: bold; }
        .presetButton:hover:not(:disabled) { background: linear-gradient(145deg, #5a5aa0, #3a3a7a); transform: scale(1.05); }
        .presetButton:disabled { opacity: 0.5; cursor: not-allowed; }
        #findRandomButton { width: 100%; background: linear-gradient(145deg, #4a4a8a, #2a2a5a); border: 1px solid #6a6a9a; color: #e0e0ff; padding: 15px; border-radius: 10px; cursor: pointer; transition: all 0.3s; font-weight: bold; margin-top: 20px; }
        #findRandomButton:hover:not(:disabled) { background: linear-gradient(145deg, #5a5aa0, #3a3a7a); transform: scale(1.05); }
        #findRandomButton:disabled { background: #333; cursor: not-allowed; opacity: 0.5; }
        #modalBackdrop { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 350; }
        #closeModal { position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: #e0e0ff; }

        /* Placeholder —Å—Ç—Ä–∞–Ω–∏—Ü—ã ‚Äî –Ω–æ–≤—ã–π —Å—Ç–∏–ª—å */
        .placeholderPage {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.8); z-index: 150; color: #e0e0ff; text-align: center;
            font-size: 1.5em; text-shadow: 2px 2px 4px rgba(0,0,0,1);
        }
        .placeholderPage h2 { font-size: 2em; margin-bottom: 10px; color: #e0e0ff; border-bottom: 2px solid #6a6a9a; padding-bottom: 10px; }
        .placeholderPage p { margin: 20px; }
        .backButton { 
            background: linear-gradient(145deg, #4a4a8a, #2a2a5a); border: 2px solid #6a6a9a; 
            color: #e0e0ff; padding: 10px 20px; border-radius: 10px; cursor: pointer; 
            font-weight: bold; transition: all 0.3s; margin-top: 20px;
        }
        .backButton:hover { background: linear-gradient(145deg, #5a5aa0, #3a3a7a); transform: scale(1.05); }
        #leaderboardList { list-style: none; padding: 0; }
        #leaderboardList li { margin: 10px 0; background: rgba(74,74,138,0.3); padding: 5px; border-radius: 5px; }
    </style>
    <!-- –ü—Ä–æ–≤–µ—Ä–∫–∞ WebGL –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –ø–µ—Ä–µ–¥ –∑–∞–≥—Ä—É–∑–∫–æ–π —Å–∫—Ä–∏–ø—Ç–æ–≤ -->
    <script>
        (function() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                document.body.innerHTML = '<div id="errorMessage" style="display: block;"><h2>–û—à–∏–±–∫–∞!</h2><p>–í–∞—à–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç WebGL. –ò–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è.</p><button onclick="location.reload()">–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞</button></div>';
                throw new Error('WebGL not supported');
            }
            console.log('WebGL supported');
        })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" onload="console.log('Three.js loaded')" onerror="console.error('Three.js failed to load'); document.getElementById('errorMessage').style.display='block'; document.getElementById('errorMessage').innerHTML='<h2>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏!</h2><p>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É Three.js. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.</p>'"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js" onload="console.log('OrbitControls loaded')" onerror="console.error('OrbitControls failed to load');"></script>
    <!-- Firebase SDK –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞ -->
    <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
</head>
<body>
    <!-- –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω–∞: hamburger –∫–∞–∫ –∫–Ω–æ–ø–∫–∞ —Å —Ç–µ–∫—Å—Ç–æ–º "–ï—â—ë" -->
    <nav id="bottomNav">
        <div class="navContainer">
            <button class="navButton active" onclick="showPage('main')">
                <span class="icon">üè†</span>
                –ì–ª–∞–≤–Ω–∞—è
            </button>
            <button class="navButton" onclick="showPage('tasks')">
                <span class="icon">üß©</span>
                –ó–∞–¥–∞—á–∏
            </button>
            <button class="navButton" onclick="showPage('training')">
                <span class="icon">üìñ</span>
                –û–±—É—á–µ–Ω–∏–µ
            </button>
            <button class="navButton" onclick="showPage('watch')">
                <span class="icon">üî≠</span>
                –°–º–æ—Ç—Ä–µ—Ç—å
            </button>
        </div>
        <button id="hamburger" onclick="toggleSidebar()">
            <span class="icon">‚â°</span>
            <span>–ï—â—ë</span> <!-- –î–æ–±–∞–≤–ª–µ–Ω —Ç–µ–∫—Å—Ç "–ï—â—ë" –ø–æ–¥ –∏–∫–æ–Ω–∫–æ–π -->
        </button>
    </nav>

    <!-- Backdrop –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ -->
    <div id="modalBackdrop" onclick="closeMultiplayerModal()"></div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞ -->
    <div id="multiplayerModal">
        <button id="closeModal" onclick="closeMultiplayerModal()">√ó</button>
        <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞</h2>
        <div class="modal-field">
            <label>–í—Ä–µ–º—è:</label>
            <input type="number" id="timeInput" min="1" value="5"> 
            <select id="timeUnit">
                <option value="min">–º–∏–Ω—É—Ç—ã</option>
                <option value="sec">—Å–µ–∫—É–Ω–¥—ã</option>
                <option value="hour">—á–∞—Å—ã</option>
            </select>
        </div>
        <div class="modal-field">
            <label>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ:</label>
            <input type="number" id="incrementInput" min="0" value="0"> —Å–µ–∫—É–Ω–¥—ã
        </div>
        <div id="presetGrid">
            <button class="presetButton" onclick="setPresetAndSearch(1,1)">1+1</button>
            <button class="presetButton" onclick="setPresetAndSearch(2,1)">2+1</button>
            <button class="presetButton" onclick="setPresetAndSearch(3,0)">3+0</button>
            <button class="presetButton" onclick="setPresetAndSearch(3,2)">3+2</button>
            <button class="presetButton" onclick="setPresetAndSearch(5,0)">5+0</button>
            <button class="presetButton" onclick="setPresetAndSearch(5,3)">5+3</button>
            <button class="presetButton" onclick="setPresetAndSearch(10,0)">10+0</button>
            <button class="presetButton" onclick="setPresetAndSearch(10,5)">10+5</button>
            <button class="presetButton" onclick="setPresetAndSearch(15,10)">15+10</button>
        </div>
        <button id="findRandomButton" onclick="findRandomPlayer()">–ù–∞–π—Ç–∏ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞</button>
    </div>

    <!-- Overlay –¥–ª—è –±–æ–∫–æ–≤–æ–π –ø–∞–Ω–µ–ª–∏ -->
    <div id="sidebarOverlay" onclick="toggleSidebar()"></div>

    <!-- –ë–æ–∫–æ–≤–∞—è –ø–∞–Ω–µ–ª—å -->
    <div id="sidebar">
        <button id="closeSidebar" onclick="toggleSidebar()">√ó</button>
        <ul>
            <li><a href="#" onclick="showPage('tournaments'); toggleSidebar(); return false;">–¢—É—Ä–Ω–∏—Ä—ã</a></li>
            <li><a href="#" onclick="showPage('leaders'); toggleSidebar(); return false;">–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</a></li>
            <li><a href="#" onclick="showPage('helpAuthor'); toggleSidebar(); return false;">–ü–æ–º–æ—â—å –∞–≤—Ç–æ—Ä—É</a></li>
            <li><a href="#" onclick="showPage('techSupport'); toggleSidebar(); return false;">–¢–µ—Ö –ø–æ–¥–¥–µ—Ä–∂–∫–∞</a></li>
            <li><a href="#" onclick="showPage('settings'); toggleSidebar(); return false;">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</a></li>
        </ul>
    </div>

    <!-- –ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω ‚Äî –¥–æ—Å–∫–∞ —É–¥–∞–ª–µ–Ω–∞ -->
    <div id="mainMenu">
        <h1>–¢–∞–≤—Ä–µ–ª–∏</h1>
        <button class="menuButton" onclick="startSinglePlayer()">–û–¥–∏–Ω–æ—á–Ω–∞—è –∏–≥—Ä–∞</button>
        <button class="menuButton" onclick="startMultiplayer()">–ú—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä</button>
        <button class="menuButton" onclick="startVsBot()" disabled>–ò–≥—Ä–∞ —Å –±–æ—Ç–æ–º (–≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ)</button>
        <button class="menuButton" onclick="startVsAI()" disabled>–ò–≥—Ä–∞ —Å –ò–ò (–≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ)</button>
        <!-- #menuBoard —É–¥–∞–ª—ë–Ω -->
    </div>
    
    <!-- –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä (—Å–∫—Ä—ã—Ç) -->
    <div id="gameContainer">
        <div id="ui">
            <div>–¢–µ–∫—É—â–∏–π –∏–≥—Ä–æ–∫: <span id="currentPlayer">–ë–µ–ª—ã–µ</span></div>
            <div id="selected">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É</div>
            <div id="status"></div>
        </div>
        <div id="gameOver">
            <h2 id="gameOverText"></h2>
            <p id="endMessage"></p>
            <button onclick="restartGame()">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
            <button onclick="backToMenu()">–í –º–µ–Ω—é</button>
        </div>
        <div id="errorMessage"></div>
    </div>

    <!-- Placeholder —Å—Ç—Ä–∞–Ω–∏—Ü—ã -->
    <div id="tasksPage" class="placeholderPage">
        <h2>–ó–∞–¥–∞—á–∏</h2>
        <p>–°–∫–æ—Ä–æ –±—É–¥–µ—Ç</p>
        <button class="backButton" onclick="showPage('main')">–ù–∞–∑–∞–¥</button>
    </div>
    <div id="trainingPage" class="placeholderPage">
        <h2>–û–±—É—á–µ–Ω–∏–µ</h2>
        <p>–°–∫–æ—Ä–æ –±—É–¥–µ—Ç</p>
        <button class="backButton" onclick="showPage('main')">–ù–∞–∑–∞–¥</button>
    </div>
    <div id="watchPage" class="placeholderPage">
        <h2>–°–º–æ—Ç—Ä–µ—Ç—å</h2>
        <p>–°–∫–æ—Ä–æ –±—É–¥–µ—Ç</p>
        <button class="backButton" onclick="showPage('main')">–ù–∞–∑–∞–¥</button>
    </div>
    <div id="tournamentsPage" class="placeholderPage">
        <h2>–¢—É—Ä–Ω–∏—Ä—ã</h2>
        <hr style="border: 2px solid #6a6a9a; width: 200px; margin: 20px auto;">
        <p>–°–∫–æ—Ä–æ –±—É–¥—É—Ç —Ç—É—Ä–Ω–∏—Ä—ã</p>
        <button class="backButton" onclick="showPage('main')">–ù–∞–∑–∞–¥</button>
    </div>
    <div id="leadersPage" class="placeholderPage">
        <h2>–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</h2>
        <ul id="leaderboardList">
            <li>1. –ò–≥—Ä–æ–∫1 - 1500 –æ—á–∫–æ–≤</li>
            <li>2. –ò–≥—Ä–æ–∫2 - 1450 –æ—á–∫–æ–≤</li>
            <li>3. –ò–≥—Ä–æ–∫3 - 1400 –æ—á–∫–æ–≤</li>
            <li>4. –ò–≥—Ä–æ–∫4 - 1350 –æ—á–∫–æ–≤</li>
            <li>5. –ò–≥—Ä–æ–∫5 - 1300 –æ—á–∫–æ–≤</li>
            <li>6. –ò–≥—Ä–æ–∫6 - 1250 –æ—á–∫–æ–≤</li>
            <li>7. –ò–≥—Ä–æ–∫7 - 1200 –æ—á–∫–æ–≤</li>
            <li>8. –ò–≥—Ä–æ–∫8 - 1150 –æ—á–∫–æ–≤</li>
            <li>9. –ò–≥—Ä–æ–∫9 - 1100 –æ—á–∫–æ–≤</li>
            <li>10. –ò–≥—Ä–æ–∫10 - 1050 –æ—á–∫–æ–≤</li>
        </ul>
        <p>–í–∞—à –Ω–∏–∫: [–Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω], –º–µ—Å—Ç–æ: [–Ω–µ –≤ —Ç–æ–ø–µ]</p>
        <button class="backButton" onclick="showPage('main')">–ù–∞–∑–∞–¥</button>
    </div>
    <div id="helpAuthorPage" class="placeholderPage">
        <h2>–ü–æ–º–æ—â—å –∞–≤—Ç–æ—Ä—É</h2>
        <p>–ó–¥–µ—Å—å –ø–æ–º–æ—â—å –∞–≤—Ç–æ—Ä—É. –ü–æ–¥–¥–µ—Ä–∂–∏—Ç–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É: [–∑–∞–≥–æ—Ç–æ–≤–∫–∞ –¥–ª—è —Å—Å—ã–ª–æ–∫/–¥–æ–Ω–∞—Ç–æ–≤]</p>
        <button class="backButton" onclick="showPage('main')">–ù–∞–∑–∞–¥</button>
    </div>
    <div id="techSupportPage" class="placeholderPage">
        <h2>–¢–µ—Ö –ø–æ–¥–¥–µ—Ä–∂–∫–∞</h2>
        <p>–ó–¥–µ—Å—å —Ç–µ—Ö –ø–æ–¥–¥–µ—Ä–∂–∫–∞. –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞ email: support@tavreli.ru</p>
        <button class="backButton" onclick="showPage('main')">–ù–∞–∑–∞–¥</button>
    </div>
    <div id="settingsPage" class="placeholderPage">
        <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
        <p>–°–∞–º –±–µ—Ä–∏ –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–π. (–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ ;)</p>
        <button class="backButton" onclick="showPage('main')">–ù–∞–∑–∞–¥</button>
    </div>
    
    <script>
        // Firebase config ‚Äî –ó–ê–ú–ï–ù–ò –ù–ê –°–í–û–ò –ö–õ–Æ–ß–ò –ò–ó FIREBASE CONSOLE (Realtime Database)
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY",
            authDomain: "YOUR_PROJECT.firebaseapp.com",
            databaseURL: "https://YOUR_PROJECT-default-rtdb.firebaseio.com/",
            projectId: "YOUR_PROJECT",
            storageBucket: "YOUR_PROJECT.appspot.com",
            messagingSenderId: "123456789",
            appId: "YOUR_APP_ID"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let isMultiplayer = false;
        let playerId = null;
        let roomId = null;
        let opponentId = null;
        let myColor = null;
        let gameRef = null;
        let queueRef = null;
        let searchTimeout = null;
        let queuePathListener = null;
        let matchesRef = null;

        // 9 –ø—Ä–µ—Å–µ—Ç–æ–≤ –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞
        const presets = [
            {time: 1, unit: 'min', increment: 1},
            {time: 2, unit: 'min', increment: 1},
            {time: 3, unit: 'min', increment: 0},
            {time: 3, unit: 'min', increment: 2},
            {time: 5, unit: 'min', increment: 0},
            {time: 5, unit: 'min', increment: 3},
            {time: 10, unit: 'min', increment: 0},
            {time: 10, unit: 'min', increment: 5},
            {time: 15, unit: 'min', increment: 10}
        ];

        function disableAll() {
            document.querySelectorAll('.presetButton').forEach(btn => btn.disabled = true);
            document.getElementById('findRandomButton').disabled = true;
        }

        function enableAll() {
            document.querySelectorAll('.presetButton').forEach(btn => btn.disabled = false);
            document.getElementById('findRandomButton').disabled = false;
            document.getElementById('findRandomButton').textContent = '–ù–∞–π—Ç–∏ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞';
        }

        function findOpponent(isPreset, presetKey = null) {
            const timeInput = parseInt(document.getElementById('timeInput').value);
            const unit = document.getElementById('timeUnit').value;
            const inc = parseInt(document.getElementById('incrementInput').value);
            if (timeInput < 1) {
                alert('–í—Ä–µ–º—è –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º–µ–Ω—å—à–µ 1!');
                enableAll();
                return;
            }

            playerId = Date.now() + Math.random().toString(36).substr(2, 9);
            const queuePath = isPreset ? `queue/preset/${presetKey}` : 'queue/random';
            queueRef = db.ref(queuePath).push({
                playerId,
                timestamp: Date.now(),
                device: navigator.userAgent.substring(0, 50)
            });

            const searchButton = document.getElementById('findRandomButton');
            const searchText = isPreset ? `–ò—â–µ–º –ø–æ ${presetKey}...` : '–ò—â–µ–º —Å–ª—É—á–∞–π–Ω–æ–≥–æ...';
            searchButton.textContent = searchText;

            searchTimeout = setTimeout(() => {
                if (queueRef) queueRef.remove();
                if (matchesRef) matchesRef.off();
                enableAll();
                alert('–û–ø–ø–æ–Ω–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
            }, 30000);

            // –°–ª—É—à–∞—Ç–µ–ª—å –º–∞—Ç—á–µ–π –¥–ª—è —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞
            matchesRef = db.ref(`matches/${playerId}`);
            matchesRef.on('value', (snap) => {
                const room = snap.val();
                if (room) {
                    matchesRef.off();
                    if (searchTimeout) clearTimeout(searchTimeout);
                    if (queueRef) queueRef.remove();
                    if (queuePathListener) queuePathListener();
                    joinRoom(room);
                }
            });

            // –°–ª—É—à–∞—Ç–µ–ª—å –æ—á–µ—Ä–µ–¥–∏ –¥–ª—è –º–∞—Ç—á–∏–Ω–≥–∞
            queuePathListener = db.ref(queuePath).on('value', (snap) => {
                const waiting = snap.val();
                if (!waiting) return;
                const entries = Object.entries(waiting);
                const otherEntries = entries.filter(([key, val]) => val.playerId !== playerId);
                if (otherEntries.length > 0) {
                    const [oppKey, oppData] = otherEntries[0];
                    opponentId = oppData.playerId;

                    // –£–¥–∞–ª–∏—Ç—å –æ–±–µ –∑–∞–ø–∏—Å–∏ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                    queueRef.remove();
                    db.ref(`${queuePath}/${oppKey}`).remove();

                    // –°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É
                    roomId = `room_${Date.now()}_${playerId}`;
                    let control;
                    if (isPreset) {
                        control = { time: timeInput, unit: 'min', increment: inc };
                    } else {
                        control = presets[Math.floor(Math.random() * presets.length)];
                    }
                    const randomColor = Math.random() < 0.5 ? 'white' : 'black';
                    const oppColor = randomColor === 'white' ? 'black' : 'white';
                    gameRef = db.ref(roomId);
                    gameRef.set({
                        board: null,
                        currentPlayer: 'white',
                        gameState: 'waiting',
                        control: control,
                        players: { [playerId]: randomColor, [opponentId]: oppColor }
                    });

                    // –£–≤–µ–¥–æ–º–∏—Ç—å –æ–±–æ–∏—Ö –æ –∫–æ–º–Ω–∞—Ç–µ
                    db.ref(`matches/${playerId}`).set(roomId);
                    db.ref(`matches/${opponentId}`).set(roomId);
                }
            });
        }

        function setPresetAndSearch(time, inc) {
            document.getElementById('timeInput').value = time;
            document.getElementById('incrementInput').value = inc;
            document.getElementById('timeUnit').value = 'min';
            disableAll();
            findOpponent(true, `${time}+${inc}`);
        }

        function findRandomPlayer() {
            disableAll();
            findOpponent(false);
        }

        function joinRoom(room) {
            closeMultiplayerModal();
            isMultiplayer = true;
            document.getElementById('bottomNav').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            initGame(true, room);
        }

        function closeMultiplayerModal() {
            document.getElementById('multiplayerModal').style.display = 'none';
            document.getElementById('modalBackdrop').style.display = 'none';
            document.getElementById('bottomNav').style.display = 'flex';
            if (searchTimeout) {
                clearTimeout(searchTimeout);
                searchTimeout = null;
            }
            if (queueRef) {
                queueRef.remove();
                queueRef = null;
            }
            if (matchesRef) {
                matchesRef.off();
                matchesRef = null;
            }
            if (queuePathListener) {
                queuePathListener();
                queuePathListener = null;
            }
            enableAll();
        }

        // –ù–∞–≤–∏–≥–∞—Ü–∏—è (–æ–±–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è overlay)
        function showPage(page) {
            // –°–∫—Ä—ã—Ç—å –≤—Å–µ
            document.querySelectorAll('.placeholderPage, #mainMenu, #gameContainer').forEach(el => el.style.display = 'none');
            document.getElementById('bottomNav').querySelectorAll('.navButton').forEach(btn => btn.classList.remove('active'));
            
            if (page === 'main') {
                document.getElementById('mainMenu').style.display = 'flex';
                document.querySelector(`[onclick="showPage('main')"]`).classList.add('active');
            } else if (page === 'tasks') {
                document.getElementById('tasksPage').style.display = 'flex';
                document.querySelector(`[onclick="showPage('tasks')"]`).classList.add('active');
            } else if (page === 'training') {
                document.getElementById('trainingPage').style.display = 'flex';
                document.querySelector(`[onclick="showPage('training')"]`).classList.add('active');
            } else if (page === 'watch') {
                document.getElementById('watchPage').style.display = 'flex';
                document.querySelector(`[onclick="showPage('watch')"]`).classList.add('active');
            } else if (page === 'tournaments') {
                document.getElementById('tournamentsPage').style.display = 'flex';
            } else if (page === 'leaders') {
                document.getElementById('leadersPage').style.display = 'flex';
            } else if (page === 'helpAuthor') {
                document.getElementById('helpAuthorPage').style.display = 'flex';
            } else if (page === 'techSupport') {
                document.getElementById('techSupportPage').style.display = 'flex';
            } else if (page === 'settings') {
                document.getElementById('settingsPage').style.display = 'flex';
            }
            // –ó–∞–∫—Ä—ã—Ç—å sidebar –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç
            document.getElementById('sidebar').classList.remove('open');
            document.getElementById('sidebarOverlay').classList.remove('open');
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('open');
        }

        // –ó–∞–∫—Ä—ã—Ç—å sidebar –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ (overlay —É–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç)
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#sidebar') && !e.target.closest('#hamburger')) {
                document.getElementById('sidebar').classList.remove('open');
                document.getElementById('sidebarOverlay').classList.remove('open');
            }
        });

        // –§—É–Ω–∫—Ü–∏–∏ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞
        function showMultiplayerModal() {
            document.getElementById('bottomNav').style.display = 'none';
            document.getElementById('multiplayerModal').style.display = 'block';
            document.getElementById('modalBackdrop').style.display = 'block';
        }

        // –§—É–Ω–∫—Ü–∏–∏ –º–µ–Ω—é
        function startSinglePlayer() {
            isMultiplayer = false;
            document.getElementById('bottomNav').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            initGame(); // –ó–∞–ø—É—Å–∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –∏–≥—Ä–æ–≤–æ–≥–æ –∫–æ–¥–∞
        }

        function startMultiplayer() {
            showMultiplayerModal();
        }
        
        function startVsBot() {
            alert('–ò–≥—Ä–∞ —Å –±–æ—Ç–æ–º –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ. –°–º. –æ–ø–∏—Å–∞–Ω–∏–µ –Ω–∏–∂–µ.');
        }
        
        function startVsAI() {
            alert('–ò–≥—Ä–∞ —Å –ò–ò –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ. –°–º. –æ–ø–∏—Å–∞–Ω–∏–µ –Ω–∏–∂–µ.'); // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–æ–≤–æ–π –∫–Ω–æ–ø–∫–∏
        }
        
        function backToMenu() {
            if (isMultiplayer && gameRef) {
                gameRef.remove(); // –û—á–∏—Å—Ç–∏—Ç—å –∫–æ–º–Ω–∞—Ç—É
                gameRef = null;
            }
            if (matchesRef) {
                matchesRef.off();
                matchesRef = null;
            }
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('bottomNav').style.display = 'flex';
            // –û—á–∏—Å—Ç–∫–∞ —Å—Ü–µ–Ω—ã/–∏–≥—Ä—ã –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ
            if (typeof scene !== 'undefined') {
                while (scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            showPage('main'); // –û–±–Ω–æ–≤–∏—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏—é
            isMultiplayer = false;
            myColor = null;
            opponentId = null;
            roomId = null;
        }
        
        function restartGame() {
            backToMenu();
            setTimeout(() => {
                if (!isMultiplayer) startSinglePlayer();
            }, 100); // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫
        }

        // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ò–ì–†–û–í–û–ô –ö–û–î (–≤–µ—Å—å –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ, –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) + –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä —Ö—É–∫–∏
        console.log('Starting script execution');
        let scene, camera, renderer, controls; // –ì–ª–æ–±–∞–ª—ã –¥–ª—è –æ—á–∏—Å—Ç–∫–∏
        function initGame(multiplayer = false, room = null) {
            isMultiplayer = multiplayer;
            if (isMultiplayer) {
                roomId = room;
                gameRef = db.ref(roomId);
                gameRef.child('players').child(playerId).once('value', (snap) => {
                    myColor = snap.val();
                });
                // –°–ª—É—à–∞—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
                gameRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data && data.gameState === 'started' && data.board) {
                        loadGameState(data);
                    }
                    if (data) {
                        currentPlayer = data.currentPlayer || 'white';
                        updateUI();
                    }
                });
            }

            // –°—Ü–µ–Ω–∞, –∫–∞–º–µ—Ä–∞, —Ä–µ–Ω–¥–µ—Ä–µ—Ä
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB, 1);
            document.body.appendChild(renderer.domElement);
            console.log('Renderer initialized');

            // –û—Å–≤–µ—â–µ–Ω–∏–µ (–≥–ª–æ–±–∞–ª—å–Ω–æ, –¥–ª—è loadGameState)
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 10, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // –ö–æ–Ω—Ç—Ä–æ–ª—ã
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 20;
            controls.enableRotate = true;
            if (/Mobi|Android/i.test(navigator.userAgent)) {
                controls.dampingFactor = 0.1;
                controls.enableDamping = false;
            }

            let isInteracting = false;
            controls.addEventListener('start', () => { isInteracting = true; });
            controls.addEventListener('end', () => { setTimeout(() => { isInteracting = false; }, 100); });

            // –î–æ—Å–∫–∞
            const board = [];
            const squareSize = 1;
            for (let x = 0; x < 8; x++) {
                board[x] = [];
                for (let z = 0; z < 8; z++) {
                    const geometry = new THREE.BoxGeometry(squareSize, 0.1, squareSize);
                    const material = new THREE.MeshLambertMaterial({ color: (x + z) % 2 === 0 ? 0xdeb887 : 0x8b4513 });
                    const square = new THREE.Mesh(geometry, material);
                    square.position.set(x - 3.5, 0, z - 3.5);
                    scene.add(square);
                    board[x][z] = { mesh: square, pieces: [] };
                }
            }
            console.log('Board created');

            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞
            let highlightMeshes = [];

            function clearHighlights() {
                highlightMeshes.forEach(mesh => scene.remove(mesh));
                highlightMeshes = [];
            }

            function showHighlights(moves) {
                clearHighlights();
                moves.forEach(([tx, tz]) => {
                    const geometry = new THREE.CircleGeometry(0.42, 32);
                    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
                    const highlight = new THREE.Mesh(geometry, material);
                    highlight.rotation.x = -Math.PI / 2;
                    highlight.position.set(tx - 3.5, 0.06, tz - 3.5);
                    scene.add(highlight);
                    highlightMeshes.push(highlight);
                });
            }

            // –ê–Ω–∏–º–∞—Ü–∏—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è
            let promotingPieces = [];

            // –ö—ç—à —Ç–µ–∫—Å—Ç—É—Ä
            const textureCache = {};

            // Hex to RGB
            function hexToRgb(hex) {
                const r = (hex >> 16) & 0xff;
                const g = (hex >> 8) & 0xff;
                const b = hex & 0xff;
                return `${r}, ${g}, ${b}`;
            }

            // Create symbol texture (unchanged)
            function createSymbolTexture(symbolType, isVolhv = false, pieceColor = 'white') {
                const key = `${symbolType}_${isVolhv}_${pieceColor}`;
                if (textureCache[key]) return textureCache[key];

                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                const isWhite = pieceColor === 'white';

                if (!isWhite) {
                    ctx.save();
                    ctx.translate(128, 128);
                    ctx.rotate(Math.PI);
                    ctx.translate(-128, -128);
                }

                const bgAlpha = 0.9;
                const whiteBase = 0xf4e4bc;
                const blackBase = 0x5c3317;
                const opponentBase = isWhite ? blackBase : whiteBase;
                const bgColor = `rgba(${hexToRgb(opponentBase)}, ${bgAlpha})`;
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, 256, 256);
                const ownBase = isWhite ? whiteBase : blackBase;
                ctx.strokeStyle = `#${ownBase.toString(16).padStart(6, '0')}`;
                ctx.lineWidth = 12;

                const headY = 196;
                const tailY = 60;
                const barbY = 176;

                switch (symbolType) {
                    case 'rato_borec':
                        ctx.beginPath();
                        ctx.moveTo(128, 60); ctx.lineTo(128, 196);
                        ctx.moveTo(60, 128); ctx.lineTo(196, 128);
                        ctx.stroke();
                        break;
                    case 'vsadnik':
                        ctx.beginPath();
                        ctx.moveTo(128, 60); ctx.lineTo(128, 196);
                        ctx.moveTo(60, 128); ctx.lineTo(196, 128);
                        ctx.moveTo(100, headY); ctx.lineTo(156, headY);
                        ctx.moveTo(100, tailY); ctx.lineTo(156, tailY);
                        ctx.moveTo(60, 100); ctx.lineTo(60, 156);
                        ctx.moveTo(196, 100); ctx.lineTo(196, 156);
                        ctx.stroke();
                        break;
                    case 'luchnik':
                        ctx.beginPath();
                        ctx.moveTo(128, tailY); ctx.lineTo(128, headY);
                        ctx.moveTo(128, headY); ctx.lineTo(110, barbY);
                        ctx.moveTo(128, headY); ctx.lineTo(146, barbY);
                        ctx.moveTo(60, 128); ctx.lineTo(196, 128);
                        ctx.stroke();
                        break;
                    case 'knyaz':
                        ctx.beginPath();
                        ctx.moveTo(128, 60); ctx.lineTo(128, 196);
                        ctx.moveTo(60, 128); ctx.lineTo(196, 128);
                        ctx.moveTo(60, 60); ctx.lineTo(196, 196);
                        ctx.moveTo(60, 196); ctx.lineTo(196, 60);
                        ctx.stroke();
                        break;
                    case 'volhv':
                        ctx.beginPath();
                        ctx.arc(128, 128, 90, 0, 2 * Math.PI);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(128, 80); ctx.lineTo(128, 176);
                        ctx.moveTo(80, 128); ctx.lineTo(176, 128);
                        ctx.moveTo(80, 80); ctx.lineTo(176, 176);
                        ctx.moveTo(80, 176); ctx.lineTo(176, 80);
                        ctx.stroke();
                        break;
                    case 'volhv_square':
                        ctx.beginPath();
                        ctx.rect(38, 38, 180, 180);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(128, 80); ctx.lineTo(128, 176);
                        ctx.moveTo(80, 128); ctx.lineTo(176, 128);
                        ctx.moveTo(80, 80); ctx.lineTo(176, 176);
                        ctx.moveTo(80, 176); ctx.lineTo(176, 80);
                        ctx.stroke();
                        break;
                    case 'V':
                        const midX1 = 100, midX2 = 156;
                        ctx.beginPath();
                        ctx.moveTo(midX1, tailY);
                        ctx.lineTo(128, headY);
                        ctx.moveTo(midX2, tailY);
                        ctx.lineTo(128, headY);
                        ctx.stroke();
                        break;
                    default:
                        ctx.font = 'bold 180px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = ctx.strokeStyle;
                        ctx.fillText('?', 128, 128);
                }

                if (!isWhite) {
                    ctx.restore();
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                textureCache[key] = texture;
                return texture;
            }

            // Update stack appearance (unchanged)
            function updateStackAppearance(stack, isSelected = false) {
                if (stack.length === 0) return;
                const topColor = stack[stack.length - 1].userData.color;
                let topBaseColor, topSymbolTint;
                if (isSelected) {
                    topBaseColor = 0x00ff00;
                    topSymbolTint = 0x006600;
                } else {
                    topBaseColor = topColor === 'white' ? 0xf4e4bc : 0x5c3317;
                    topSymbolTint = topColor === 'white' ? topBaseColor : 0xffffff;
                }

                stack.forEach((p, i) => {
                    const pieceColor = p.userData.color;
                    const baseColor = isSelected ? topBaseColor : (pieceColor === 'white' ? 0xf4e4bc : 0x5c3317);
                    const symbolTint = isSelected ? topSymbolTint : (pieceColor === 'white' ? baseColor : 0xffffff);
                    p.material.color.set(baseColor);
                    p.children.forEach(child => {
                        if (child.material) {
                            child.material.color.set(symbolTint);
                        }
                    });
                });
            }

            // Create piece (with fix: hasMoved: false)
            function createPiece(color, type = 'ratnik', potentialType = null, isTransformed = false, originalPotentialType = null) {
                const baseColor = color === 'white' ? 0xf4e4bc : 0x5c3317;
                const symbolColor = baseColor;
                const baseGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.45, 8, 1, false);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: baseColor });
                const piece = new THREE.Mesh(baseGeometry, baseMaterial);
                piece.rotation.y = Math.PI / 8;

                let symbolType = type;
                let isVolhvSymbol = false;
                if (type === 'ratnik') {
                    symbolType = 'V';
                } 
                if (type === 'volhv') {
                    symbolType = isTransformed ? 'volhv_square' : 'volhv';
                    isVolhvSymbol = true;
                }

                let sideSymbolType = symbolType;
                let sideIsVolhvSymbol = isVolhvSymbol;
                if (type === 'ratnik' && potentialType) {
                    sideSymbolType = potentialType;
                    if (potentialType === 'volhv') {
                        sideSymbolType = 'volhv_square';
                        sideIsVolhvSymbol = true;
                    }
                }

                if (symbolType) {
                    const symbolGeometry = new THREE.CircleGeometry(0.28, 32);
                    const symbolTexture = createSymbolTexture(symbolType, isVolhvSymbol, color);
                    const symbolMaterial = new THREE.MeshBasicMaterial({ 
                        map: symbolTexture, 
                        transparent: false,
                        side: THREE.DoubleSide,
                        color: color === 'white' ? new THREE.Color(symbolColor) : new THREE.Color(0xffffff)
                    });
                    const symbolMesh = new THREE.Mesh(symbolGeometry, symbolMaterial);
                    symbolMesh.position.y = 0.25;
                    symbolMesh.rotation.x = -Math.PI / 2;
                    symbolMesh.rotation.z = -(Math.PI / 6 - Math.PI / 36);
                    piece.add(symbolMesh);

                    const numFacets = 8;
                    const facetAngle = 2 * Math.PI / numFacets;
                    for (let i = 0; i < numFacets; i++) {
                        if (i % 2 !== 0) continue;
                        const angle = i * facetAngle + piece.rotation.y;
                        const stickerRadius = 0.15;
                        const stickerGeometry = new THREE.CircleGeometry(stickerRadius, 32);
                        const stickerTexture = createSymbolTexture(sideSymbolType, sideIsVolhvSymbol, color);
                        const stickerMaterial = new THREE.MeshBasicMaterial({ 
                            map: stickerTexture, 
                            transparent: false,
                            side: THREE.DoubleSide,
                            color: color === 'white' ? new THREE.Color(symbolColor) : new THREE.Color(0xffffff)
                        });
                        const stickerMesh = new THREE.Mesh(stickerGeometry, stickerMaterial);
                        const epsilon = -0.02;
                        stickerMesh.position.set(
                            (0.4 + epsilon) * Math.sin(angle),
                            0,
                            (0.4 + epsilon) * Math.cos(angle)
                        );
                        stickerMesh.rotation.y = angle + Math.PI;
                        if (sideSymbolType === 'luchnik') {
                            stickerMesh.rotation.z = Math.PI;
                        }
                        piece.add(stickerMesh);
                    }
                }

                piece.userData = { 
                    color, 
                    type, 
                    potentialType,
                    originalPotentialType,
                    isTransformedRatnik: isTransformed,
                    selected: false, 
                    hasMoved: false  // Fixed: all start unmoved
                };
                return piece;
            }

            // Update piece geometry (unchanged)
            function updatePieceGeometry(piece, newType, newPotential = null, newIsTransformed = false, originalPotential = null, animate = false) {
                const oldPos = piece.position.clone();
                const oldScale = piece.scale.clone();
                const oldRotationY = piece.rotation.y;
                scene.remove(piece);
                const newPiece = createPiece(piece.userData.color, newType, newPotential, newIsTransformed, originalPotential);
                newPiece.position.copy(oldPos);
                newPiece.rotation.y = oldRotationY;
                newPiece.userData.hasMoved = piece.userData.hasMoved;
                const x = Math.round(oldPos.x + 3.5);
                const z = Math.round(oldPos.z + 3.5);
                const stack = board[x][z].pieces;
                const idx = stack.indexOf(piece);
                if (idx !== -1) {
                    stack[idx] = newPiece;
                }
                if (animate) {
                    newPiece.rotation.x = 0;
                    promotingPieces.push({
                        piece: newPiece,
                        startTime: Date.now(),
                        targetRotation: Math.PI,
                        originalScale: oldScale
                    });
                } else {
                    newPiece.scale.copy(oldScale);
                    newPiece.rotation.x = 0;
                }
                scene.add(newPiece);
                return newPiece;
            }

            // –ù–∞—á–∞–ª—å–Ω–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ (unchanged)
            const pieceTypesWhite = ['rato_borec', 'vsadnik', 'luchnik', 'knyaz', 'volhv', 'luchnik', 'vsadnik', 'rato_borec'];
            const pieceTypesBlack = ['rato_borec', 'vsadnik', 'luchnik', 'knyaz', 'volhv', 'luchnik', 'vsadnik', 'rato_borec'];
            for (let x = 0; x < 8; x++) {
                const potentialW = pieceTypesWhite[x];
                const pieceW = createPiece('white', 'ratnik', potentialW);
                pieceW.position.set(x - 3.5, 0.2, 6 - 3.5);
                board[x][6].pieces.push(pieceW);
                scene.add(pieceW);

                const potentialB = pieceTypesBlack[x];
                const pieceB = createPiece('black', 'ratnik', potentialB);
                pieceB.position.set(x - 3.5, 0.2, 1 - 3.5);
                board[x][1].pieces.push(pieceB);
                scene.add(pieceB);
            }
            for (let x = 0; x < 8; x++) {
                const type = pieceTypesWhite[x];
                const piece = createPiece('white', type);
                piece.position.set(x - 3.5, 0.2, 7 - 3.5);
                board[x][7].pieces.push(piece);
                scene.add(piece);
                const typeB = pieceTypesBlack[x];
                const pieceB = createPiece('black', typeB);
                pieceB.position.set(x - 3.5, 0.2, 0 - 3.5);
                board[x][0].pieces.push(pieceB);
                scene.add(pieceB);
            }
            console.log('Pieces placed');

            // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π –¥–æ—Å–∫–∏ –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞)
            if (isMultiplayer) {
                gameRef.child('board').transaction((current) => {
                    if (current === null) {
                        return serializeBoard(board);
                    }
                    return current;
                });
                gameRef.child('gameState').set('started');
            }

            // Clone board (unchanged)
            function cloneBoard(origBoard) {
                const newBoard = [];
                for (let x = 0; x < 8; x++) {
                    newBoard[x] = [];
                    for (let z = 0; z < 8; z++) {
                        newBoard[x][z] = { pieces: origBoard[x][z].pieces.map(p => {
                            const clone = createPiece(p.userData.color, p.userData.type, p.userData.potentialType, p.userData.isTransformedRatnik, p.userData.originalPotentialType);
                            clone.userData.hasMoved = p.userData.hasMoved;
                            clone.position.copy(p.position);
                            clone.scale.copy(p.scale);
                            clone.rotation.y = p.rotation.y;
                            p.children.forEach(child => {
                                const childClone = child.clone();
                                if (childClone.material) {
                                    childClone.material = child.material.clone();
                                }
                                clone.add(childClone);
                            });
                            return clone;
                        }) };
                    }
                }
                return newBoard;
            }

            // Serialize board for DB
            function serializeBoard(b) {
                return b.map(row => row.map(cell => cell.pieces.map(p => ({
                    color: p.userData.color,
                    type: p.userData.type,
                    potentialType: p.userData.potentialType,
                    isTransformedRatnik: p.userData.isTransformedRatnik,
                    originalPotentialType: p.userData.originalPotentialType,
                    hasMoved: p.userData.hasMoved,
                    position: { x: p.position.x, y: p.position.y, z: p.position.z },
                    rotation: { y: p.rotation.y },
                    scale: { x: p.scale.x, y: p.scale.y, z: p.scale.z }
                }))));
            }

            // Load game state from DB
            function loadGameState(data) {
                // –û—á–∏—Å—Ç–∏—Ç—å —Å—Ü–µ–Ω—É, —Å–æ—Ö—Ä–∞–Ω–∏–≤ –æ–≥–Ω–∏
                const lights = [];
                scene.children.forEach(child => {
                    if (child.type === 'DirectionalLight' || child.type === 'AmbientLight') {
                        lights.push(child);
                    } else {
                        scene.remove(child);
                    }
                });
                scene.children.length = 0;
                lights.forEach(light => scene.add(light));

                board = [];
                // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–æ—Å–∫—É
                for (let x = 0; x < 8; x++) {
                    board[x] = [];
                    for (let z = 0; z < 8; z++) {
                        const geometry = new THREE.BoxGeometry(1, 0.1, 1);
                        const material = new THREE.MeshLambertMaterial({ color: (x + z) % 2 === 0 ? 0xdeb887 : 0x8b4513 });
                        const square = new THREE.Mesh(geometry, material);
                        square.position.set(x - 3.5, 0, z - 3.5);
                        scene.add(square);
                        board[x][z] = { mesh: square, pieces: [] };
                        if (data.board && data.board[x] && data.board[x][z]) {
                            data.board[x][z].forEach(pData => {
                                const p = createPiece(pData.color, pData.type, pData.potentialType, pData.isTransformedRatnik, pData.originalPotentialType);
                                p.userData.hasMoved = pData.hasMoved;
                                p.position.set(pData.position.x, pData.position.y, pData.position.z);
                                p.rotation.y = pData.rotation.y;
                                p.scale.set(pData.scale.x, pData.scale.y, pData.scale.z);
                                board[x][z].pieces.push(p);
                                scene.add(p);
                            });
                        }
                    }
                }
                currentPlayer = data.currentPlayer;
                updateUI();
            }

            // Get moves (unchanged)
            function getMoves(piece, x, z, boardState, player) {
                const moves = getRawMoves(piece, x, z, boardState, player);
                const filteredMoves = moves.filter(([mx, mz]) => {
                    const targetStack = boardState[mx][mz].pieces;
                    if (targetStack.length > 0 && targetStack[targetStack.length - 1].userData.type === 'volhv') {
                        return false;
                    }
                    return true;
                });
                return filteredMoves;
            }

            // Get raw moves (with fix: !isAttack for castling)
            function getRawMoves(piece, x, z, boardState, player, isAttack = false) {
                const moves = [];
                const dir = player === 'white' ? -1 : 1;
                const opponent = player === 'white' ? 'black' : 'white';
                const type = piece.userData.type;
                const startRow = player === 'white' ? 7 : 0;

                function addLineMoves(dx, dz) {
                    for (let i = 1; i < 8; i++) {
                        const nx = x + i * dx;
                        const nz = z + i * dz;
                        if (nx < 0 || nx >= 8 || nz < 0 || nz >= 8) break;
                        moves.push([nx, nz]);
                        if (boardState[nx][nz].pieces.length > 0) break;
                    }
                }

                switch (type) {
                    case 'volhv':
                        const kingDirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                        kingDirs.forEach(([dx, dz]) => {
                            const nx = x + dx, nz = z + dz;
                            if (nx >= 0 && nx < 8 && nz >= 0 && nz < 8) moves.push([nx, nz]);
                        });
                        // Fixed castling: only if !isAttack
                        if (!isAttack && !piece.userData.hasMoved && z === startRow && x === 4) {
                            if (isInCheck(player, boardState)) {
                                break;
                            }
                            // Kingside
                            const rookX = 7;
                            const rookStack = boardState[rookX][z].pieces;
                            if (rookStack.length > 0) {
                                const rook = rookStack[rookStack.length - 1];
                                if (rook.userData.type === 'rato_borec' && rook.userData.color === player && !rook.userData.hasMoved) {
                                    let empty = true;
                                    for (let i = 5; i <= 6; i++) {
                                        if (boardState[i][z].pieces.length > 0) empty = false;
                                    }
                                    const opponent = player === 'white' ? 'black' : 'white';
                                    if (empty && !isUnderAttack(5, z, opponent, boardState) && !isUnderAttack(6, z, opponent, boardState)) {
                                        moves.push([6, z]);
                                    }
                                }
                            }
                            // Queenside
                            const rookQX = 0;
                            const rookQStack = boardState[rookQX][z].pieces;
                            if (rookQStack.length > 0) {
                                const rookQ = rookQStack[rookQStack.length - 1];
                                if (rookQ.userData.type === 'rato_borec' && rookQ.userData.color === player && !rookQ.userData.hasMoved) {
                                    let emptyQ = true;
                                    for (let i = 1; i <= 3; i++) {
                                        if (boardState[i][z].pieces.length > 0) emptyQ = false;
                                    }
                                    if (emptyQ && !isUnderAttack(2, z, opponent, boardState) && !isUnderAttack(3, z, opponent, boardState)) {
                                        moves.push([2, z]);
                                    }
                                }
                            }
                        }
                        break;
                    case 'vsadnik':
                        const knightMoves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                        knightMoves.forEach(([dx, dz]) => {
                            const nx = x + dx, nz = z + dz;
                            if (nx >= 0 && nx < 8 && nz >= 0 && nz < 8) moves.push([nx, nz]);
                        });
                        break;
                    case 'knyaz':
                        addLineMoves(1, 0); addLineMoves(-1, 0); addLineMoves(0, 1); addLineMoves(0, -1);
                        addLineMoves(1, 1); addLineMoves(-1, -1); addLineMoves(1, -1); addLineMoves(-1, 1);
                        break;
                    case 'rato_borec':
                        addLineMoves(1, 0); addLineMoves(-1, 0); addLineMoves(0, 1); addLineMoves(0, -1);
                        break;
                    case 'luchnik':
                        addLineMoves(1, 1); addLineMoves(-1, -1); addLineMoves(1, -1); addLineMoves(-1, 1);
                        break;
                    case 'ratnik':
                        const fwd1 = [x, z + dir];
                        if (fwd1[1] >= 0 && fwd1[1] < 8) {
                            const targetStack1 = boardState[fwd1[0]][fwd1[1]].pieces;
                            const isEmptyOrOwn = targetStack1.length === 0 || targetStack1[targetStack1.length - 1].userData.color === player;
                            if (isEmptyOrOwn) moves.push(fwd1);
                        }
                        if (!piece.userData.hasMoved) {
                            const fwd2 = [x, z + 2 * dir];
                            const midZ = z + dir;
                            if (fwd2[1] >= 0 && fwd2[1] < 8 && midZ >= 0 && midZ < 8) {
                                const midStack = boardState[x][midZ].pieces;
                                const targetStack2 = boardState[x][fwd2[1]].pieces;
                                const isMidEmpty = midStack.length === 0;
                                const isTargetEmptyOrOwn = targetStack2.length === 0 || targetStack2[targetStack2.length - 1].userData.color === player;
                                if (isMidEmpty && isTargetEmptyOrOwn) {
                                    moves.push(fwd2);
                                }
                            }
                        }
                        [[1, dir], [-1, dir]].forEach(([dx, dz]) => {
                            const nx = x + dx, nz = z + dz;
                            if (nx >= 0 && nx < 8 && nz >= 0 && nz < 8) {
                                const targetStack = boardState[nx][nz].pieces;
                                if (isAttack || (targetStack.length > 0 && targetStack[targetStack.length - 1].userData.color === opponent)) {
                                    moves.push([nx, nz]);
                                }
                            }
                        });
                        break;
                }
                return moves;
            }

            // Is under attack (unchanged)
            function isUnderAttack(x, z, attackerColor, simBoard) {
                for (let ax = 0; ax < 8; ax++) {
                    for (let az = 0; az < 8; az++) {
                        const stack = simBoard[ax][az].pieces;
                        if (stack.length === 0) continue;
                        const topPiece = stack[stack.length - 1];
                        if (topPiece.userData.color === attackerColor) {
                            const attacks = getRawMoves(topPiece, ax, az, simBoard, attackerColor, true);
                            if (attacks.some(([mx, mz]) => mx === x && mz === z)) return true;
                        }
                    }
                }
                return false;
            }

            // Find volhv (unchanged)
            function findVolhv(player, simBoard = board) {
                for (let x = 0; x < 8; x++) {
                    for (let z = 0; z < 8; z++) {
                        const stack = simBoard[x][z].pieces;
                        for (let p of stack) {
                            if (p.userData.type === 'volhv' && p.userData.color === player) {
                                return { x, z, stack };
                            }
                        }
                    }
                }
                return null;
            }

            // Is in check (unchanged)
            function isInCheck(player, simBoard) {
                const volhv = findVolhv(player, simBoard);
                if (!volhv) return false;
                const opponent = player === 'white' ? 'black' : 'white';
                return isUnderAttack(volhv.x, volhv.z, opponent, simBoard);
            }

            // Has legal moves (unchanged)
            function hasLegalMoves(player, origBoard) {
                for (let x = 0; x < 8; x++) {
                    for (let z = 0; z < 8; z++) {
                        const stack = origBoard[x][z].pieces;
                        if (stack.length === 0) continue;
                        const topPiece = stack[stack.length - 1];
                        if (topPiece.userData.color !== player) continue;
                        for (let subIdx = 0; subIdx < stack.length; subIdx++) {
                            const moves = getMoves(topPiece, x, z, origBoard, player);
                            for (let [tx, tz] of moves) {
                                const simBoard = simulateMove(origBoard, x, z, tx, tz, subIdx, player);
                                if (!isInCheck(player, simBoard)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            // Simulate move (unchanged)
            function simulateMove(origBoard, fromX, fromZ, toX, toZ, subIndex, player) {
                const simBoard = cloneBoard(origBoard);
                const stack = simBoard[fromX][fromZ].pieces;
                const movingPieces = stack.splice(subIndex);
                const newStack = simBoard[toX][toZ].pieces;
                const baseHeight = newStack.length * 0.6 + 0.2;
                movingPieces.forEach((p, i) => {
                    const height = baseHeight + i * 0.6;
                    p.position.set(toX - 3.5, height, toZ - 3.5);
                });
                newStack.push(...movingPieces);

                // Castling
                const startRow = player === 'white' ? 7 : 0;
                if (fromX === 4 && fromZ === startRow && toZ === fromZ && movingPieces[0].userData.type === 'volhv') {
                    let rookFromX, rookToX;
                    if (toX === 6) {
                        rookFromX = 7;
                        rookToX = 5;
                    } else if (toX === 2) {
                        rookFromX = 0;
                        rookToX = 3;
                    }
                    if (rookFromX !== undefined) {
                        const rookStack = simBoard[rookFromX][startRow].pieces;
                        if (rookStack.length > 0) {
                            const rook = rookStack[rookStack.length - 1];
                            if (rook.userData.type === 'rato_borec' && rook.userData.color === player && !rook.userData.hasMoved) {
                                const rookSubIndex = rookStack.length - 1;
                                const rookPieces = rookStack.splice(rookSubIndex);
                                rookPieces.forEach(p => p.userData.hasMoved = true);
                                const rookNewStack = simBoard[rookToX][startRow].pieces;
                                const rookBaseHeight = rookNewStack.length * 0.6 + 0.2;
                                rookPieces.forEach((p, i) => {
                                    const height = rookBaseHeight + i * 0.6;
                                    p.position.set(rookToX - 3.5, height, startRow - 3.5);
                                });
                                rookNewStack.push(...rookPieces);
                                movingPieces.forEach(p => p.userData.hasMoved = true);
                            }
                        }
                    }
                }

                return simBoard;
            }

            // Handle transformations (unchanged)
            function handleTransformationsAfterMove(targetX, targetZ, player) {
                const targetStack = board[targetX][targetZ].pieces;
                if (targetStack.length === 0) return;

                let promotionMessage = null;
                const topPiece = targetStack[targetStack.length - 1];
                const lastRow = player === 'white' ? 0 : 7;
                if (topPiece.userData.type === 'ratnik' && targetZ === lastRow && topPiece.userData.potentialType) {
                    let transformType = topPiece.userData.potentialType;
                    const originalPotential = topPiece.userData.potentialType;
                    updatePieceGeometry(topPiece, transformType, null, true, originalPotential, true);
                    promotionMessage = `–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –≤ ${transformType}!`;
                }

                for (let i = 0; i < targetStack.length - 1; i++) {
                    const p = targetStack[i];
                    if (p.userData.isTransformedRatnik && p.userData.originalPotentialType !== null) {
                        updatePieceGeometry(p, 'ratnik', p.userData.originalPotentialType, false);
                    }
                }

                if (promotionMessage) {
                    document.getElementById('status').textContent = promotionMessage;
                }
                updateStackAppearance(targetStack, false);
            }

            // Perform castling (unchanged)
            function performCastling(boardState, fromX, toX, z, player) {
                const startRow = player === 'white' ? 7 : 0;
                let rookFromX, rookToX;
                if (toX === 6) {
                    rookFromX = 7;
                    rookToX = 5;
                } else if (toX === 2) {
                    rookFromX = 0;
                    rookToX = 3;
                }
                if (rookFromX !== undefined) {
                    const rookStack = boardState[rookFromX][z].pieces;
                    if (rookStack.length > 0) {
                        const rook = rookStack[rookStack.length - 1];
                        if (rook.userData.type === 'rato_borec' && rook.userData.color === player && !rook.userData.hasMoved) {
                            rookStack.pop();
                            rook.userData.hasMoved = true;
                            const rookNewStack = boardState[rookToX][z].pieces;
                            const rookBaseHeight = rookNewStack.length * 0.6 + 0.2;
                            rook.position.set(rookToX - 3.5, rookBaseHeight, z - 3.5);
                            rookNewStack.push(rook);
                            updateStackAppearance(rookStack, false);
                            updateStackAppearance(rookNewStack, false);
                        }
                    }
                }
            }

            // –ö–∞–º–µ—Ä–∞
            camera.position.set(0, 10, 5);
            controls.target.set(0, 0, 0);

            // Raycaster
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let selectedStack = null;
            let currentPlayer = 'white';

            // Update UI (unchanged, with back button in gameOver)
            function updateUI() {
                document.getElementById('currentPlayer').textContent = currentPlayer === 'white' ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ';
                document.getElementById('selected').textContent = selectedStack ? `–í—ã–±—Ä–∞–Ω–∞ –ø–æ–¥–±–∞—à–Ω—è (${selectedStack.stack.length - selectedStack.index} —Ñ–∏–≥—É—Ä)` : '–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É';
                
                const playerToMove = currentPlayer;
                const opponent = playerToMove === 'white' ? 'black' : 'white';
                const inCheck = isInCheck(playerToMove, board);
                const hasLegal = hasLegalMoves(playerToMove, board);
                let status = document.getElementById('status').textContent;
                let showGameOver = false;
                let gameOverText = '';
                let endMessage = '';

                if (!hasLegal) {
                    showGameOver = true;
                    if (inCheck) {
                        gameOverText = `–ú–∞—Ç! ${opponent === 'white' ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ'} –ø–æ–±–µ–¥–∏–ª–∏!`;
                        endMessage = `–ü–æ–±–µ–¥–∞ –∑–∞ ${opponent === 'white' ? '–±–µ–ª—ã–º–∏' : '—á—ë—Ä–Ω—ã–º–∏'}!`;
                    } else {
                        gameOverText = '–ù–∏—á—å—è!';
                        endMessage = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞ –≤–Ω–∏—á—å—é –ø–æ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—é —Ö–æ–¥–æ–≤.';
                    }
                } else if (inCheck) {
                    status = '–®–∞—Ö!';
                }

                document.getElementById('status').textContent = status;
                if (showGameOver) {
                    document.getElementById('gameOverText').textContent = gameOverText;
                    document.getElementById('endMessage').textContent = endMessage;
                    document.getElementById('gameOver').style.display = 'block';
                    if (isMultiplayer) {
                        gameRef.child('gameState').set('ended');
                        gameRef.child('winner').set(opponent);
                    }
                }
            }

            // Highlight substack (unchanged)
            function highlightSubstack(substack, isSelected) {
                updateStackAppearance(substack, isSelected);
            }

            // On click (unchanged, with castling fix + –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä: —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –º–æ–π —Ö–æ–¥, –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å)
            function onClick(event) {
                if (event.type === 'touchend') {
                    event.preventDefault();
                }
                if (isInteracting) {
                    setTimeout(() => onClick(event), 50);
                    return;
                }
                if (isMultiplayer && currentPlayer !== myColor) return; // –¢–æ–ª—å–∫–æ —Å–≤–æ–π —Ö–æ–¥

                const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                const clientY = event.clientY || (event.touches && event.touches[0].clientY);
                if (!clientX) return;

                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    let ix, iz, stack, index;

                    if (obj.userData && !selectedStack) {
                        ix = Math.round(obj.position.x + 3.5);
                        iz = Math.round(obj.position.z + 3.5);
                        stack = board[ix][iz].pieces;
                        index = stack.indexOf(obj);
                        if (index !== -1) {
                            const topPiece = stack[stack.length - 1];
                            const topColor = topPiece.userData.color;
                            if (topColor === currentPlayer) {
                                selectedStack = { stack, index };
                                const substack = stack.slice(index);
                                highlightSubstack(substack, true);
                                const rawMoves = getMoves(topPiece, ix, iz, board, currentPlayer);
                                const legalMoves = [];
                                rawMoves.forEach(([tx, tz]) => {
                                    const simBoard = simulateMove(board, ix, iz, tx, tz, index, currentPlayer);
                                    if (!isInCheck(currentPlayer, simBoard)) {
                                        legalMoves.push([tx, tz]);
                                    }
                                });
                                showHighlights(legalMoves);
                                updateUI();
                                return;
                            }
                        }
                    } else if (!selectedStack) {
                        if (obj.position.y === 0 && obj.geometry.type === 'BoxGeometry') {
                            ix = Math.round(obj.position.x + 3.5);
                            iz = Math.round(obj.position.z + 3.5);
                            if (ix >= 0 && ix < 8 && iz >= 0 && iz < 8) {
                                stack = board[ix][iz].pieces;
                                if (stack.length > 0) {
                                    const topPiece = stack[stack.length - 1];
                                    if (topPiece.userData.color === currentPlayer) {
                                        index = stack.length - 1;
                                        selectedStack = { stack, index };
                                        const substack = stack.slice(index);
                                        highlightSubstack(substack, true);
                                        const rawMoves = getMoves(topPiece, ix, iz, board, currentPlayer);
                                        const legalMoves = [];
                                        rawMoves.forEach(([tx, tz]) => {
                                            const simBoard = simulateMove(board, ix, iz, tx, tz, index, currentPlayer);
                                            if (!isInCheck(currentPlayer, simBoard)) {
                                                legalMoves.push([tx, tz]);
                                            }
                                        });
                                        showHighlights(legalMoves);
                                        updateUI();
                                        return;
                                    }
                                }
                            }
                        }
                    } else if (selectedStack) {
                        const targetX = Math.round(obj.position.x + 3.5);
                        const targetZ = Math.round(obj.position.z + 3.5);
                        if (targetX >= 0 && targetX < 8 && targetZ >= 0 && targetZ < 8) {
                            const selX = Math.round(selectedStack.stack[0].position.x + 3.5);
                            const selZ = Math.round(selectedStack.stack[0].position.z + 3.5);
                            const topPiece = selectedStack.stack[selectedStack.stack.length - 1];
                            let rawMoves = getMoves(topPiece, selX, selZ, board, currentPlayer);
                            const isRawValid = rawMoves.some(([mx, mz]) => mx === targetX && mz === targetZ);
                            if (isRawValid) {
                                const simBoard = simulateMove(board, selX, selZ, targetX, targetZ, selectedStack.index, currentPlayer);
                                if (!isInCheck(currentPlayer, simBoard)) {
                                    const targetStackBefore = board[targetX][targetZ].pieces;
                                    const isVolhvTop = targetStackBefore.length > 0 && targetStackBefore[targetStackBefore.length - 1].userData.type === 'volhv';
                                    if (!isVolhvTop) {
                                        const isCastling = topPiece.userData.type === 'volhv' && selX === 4 && selZ === (currentPlayer === 'white' ? 7 : 0) && targetZ === selZ && (targetX === 6 || targetX === 2);
                                        const movingPieces = selectedStack.stack.splice(selectedStack.index);
                                        movingPieces.forEach(p => p.userData.hasMoved = true);
                                        const newStack = board[targetX][targetZ].pieces;
                                        const baseHeight = newStack.length * 0.6 + 0.2;
                                        movingPieces.forEach((p, i) => {
                                            const height = baseHeight + i * 0.6;
                                            p.position.set(targetX - 3.5, height, targetZ - 3.5);
                                        });
                                        newStack.push(...movingPieces);

                                        const lowerCount = newStack.length - movingPieces.length;
                                        for (let i = 0; i < lowerCount; i++) {
                                            const oldP = newStack[i];
                                            if (oldP.userData.color !== currentPlayer) {
                                                scene.remove(oldP);
                                                const newP = createPiece(oldP.userData.color, oldP.userData.type, oldP.userData.potentialType, oldP.userData.isTransformedRatnik, oldP.userData.originalPotentialType);
                                                newP.userData = { ...oldP.userData };
                                                newP.userData.hasMoved = oldP.userData.hasMoved;
                                                newP.position.copy(oldP.position);
                                                newStack[i] = newP;
                                                scene.add(newP);
                                            }
                                        }

                                        if (isCastling) {
                                            performCastling(board, selX, targetX, targetZ, currentPlayer);
                                            document.getElementById('status').textContent = '–†–æ–∫–∏—Ä–æ–≤–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!';
                                        }

                                        handleTransformationsAfterMove(targetX, targetZ, currentPlayer);

                                        const lastRow = currentPlayer === 'white' ? 0 : 7;
                                        for (let x = 0; x < 8; x++) {
                                            for (let z = 0; z < 8; z++) {
                                                if (z === lastRow) {
                                                    const stack = board[x][z].pieces;
                                                    if (stack.length > 0) {
                                                        const top = stack[stack.length - 1];
                                                        if (top.userData.type === 'ratnik' && top.userData.potentialType) {
                                                            let transformType = top.userData.potentialType;
                                                            const originalPotential = top.userData.potentialType;
                                                            updatePieceGeometry(top, transformType, null, true, originalPotential, true);
                                                            document.getElementById('status').textContent = `–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –≤ ${transformType}!`;
                                                            updateStackAppearance(stack, false);
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        if (selectedStack.index > 0) {
                                            updateStackAppearance(selectedStack.stack, false);
                                        }

                                        updateStackAppearance(newStack, false);

                                        clearHighlights();
                                        selectedStack = null;
                                        currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

                                        // –ú—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä: –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å
                                        if (isMultiplayer) {
                                            const newBoardData = serializeBoard(board);
                                            gameRef.child('board').set(newBoardData);
                                            gameRef.child('currentPlayer').set(currentPlayer);
                                        }

                                        updateUI();
                                        return;
                                    } else {
                                        document.getElementById('status').textContent = '–ù–µ–ª—å–∑—è —Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –≤–æ–ª—Ö–≤–∞!';
                                    }
                                } else {
                                    document.getElementById('status').textContent = '–•–æ–¥ –æ—Å—Ç–∞–≤–ª—è–µ—Ç —à–∞—Ö!';
                                }
                            } else {
                                document.getElementById('status').textContent = '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ö–æ–¥!';
                            }
                            clearHighlights();
                            const substack = selectedStack ? selectedStack.stack.slice(selectedStack.index) : [];
                            highlightSubstack(substack, false);
                            selectedStack = null;
                            updateUI();
                            return;
                        }
                    }
                } else {
                    clearHighlights();
                    if (selectedStack) {
                        const substack = selectedStack.stack.slice(selectedStack.index);
                        highlightSubstack(substack, false);
                        selectedStack = null;
                        updateUI();
                    }
                }
            }

            window.addEventListener('click', onClick, { passive: false });
            window.addEventListener('touchend', (e) => {
                e.preventDefault();
                onClick(e.changedTouches[0]);
            }, { passive: false });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Animate (unchanged)
            function animate() {
                requestAnimationFrame(animate);
                controls.update();

                const now = Date.now();
                promotingPieces = promotingPieces.filter(anim => {
                    const elapsed = now - anim.startTime;
                    if (elapsed > 800) {
                        anim.piece.rotation.x = 0;
                        anim.piece.scale.copy(anim.originalScale);
                        return false;
                    }
                    const progress = elapsed / 800;
                    anim.piece.rotation.x = progress * anim.targetRotation;
                    anim.piece.scale.copy(anim.originalScale);
                    return true;
                });

                renderer.render(scene, camera);
            }
            updateUI();
            animate();
            console.log('Animation loop started');
        }
    </script>
</body>
</html>